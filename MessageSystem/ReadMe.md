Messaging system that uses Concurrency, file I/O, and complex Java GUI.
  
  In the course of our project development, we crafted a messaging platform tailored specifically for user communication within the context of an online marketplace. This platform has been thoughtfully designed to cater to the distinct needs and roles of both sellers and consumers, providing a comprehensive and effortless experience for users engaging in conversations. One of the key features we implemented is a set of actions that users can employ during their interactions. These actions include sending, editing, and deleting messages, creating flexible communication between the two parties. In regards to editing, the message in question will be explicitly labeled as modified for both users. Deleted messages will only be excluded for the person who initiated the deletion. The other participant in the conversation will still be able to view the message unless they perform the same operation. Notably, users have the convenience of accessing and reviewing their various conversations in a scrollable format, ensuring that conversational data is not only recorded but also readily accessible at any given time. Privacy and data security are critical in our platform design. We have implemented stringent measures to restrict messaging to only the consumer and seller involved, underscoring our commitment to user privacy and data security. This focus ensures that sensitive information remains protected and interactions are limited to the intended parties. Upon entering the system, users can create accounts, choosing roles as either sellers or consumers. Each role comes with unique permissions and functionalities. For instance, sellers can create up to eight stores during account creation, promoting an organized approach to managing their distinct products. The messaging system is structured to facilitate seamless interactions between these two roles, with sellers exclusively interacting with consumers, and vice versa. Consumers can search for specific stores to initiate conversations, while sellers can search for particular consumers to engage with. Stores act as pivotal entities, serving as intermediary labels through which consumers can message sellers based on their product needs. This streamlined interaction system promotes a user-friendly environment, ensuring that users can easily connect with their intended recipients. Our project also places a strong emphasis on enhancing the user experience through file manipulation capabilities. Users can export their entire conversation history as CSV files, preserving critical details such as timestamps, message contents, and participant information. Additionally, the platform supports the importing of external text files into ongoing conversations, facilitating a smooth integration of outside information into the messaging interface. To further empower users, our platform incorporates visibility management features. Users have the ability to actively block others, effectively preventing any further messaging between the two parties. This feature renders them invisible to specific individuals, making them unsearchable within the application and ensuring their online privacy is maintained. In summary, our messaging platform represents a comprehensive and user-centric solution within the online marketplace context. With a focus on privacy, data security, versatile communication actions, role-specific functionalities, file manipulation capabilities, and visibility management features, our project aims to deliver an enriched user experience that is both intuitive and dynamic.
  
  To further build on Project 4, we implemented Concurrency, Network I/O, and an advanced Java GUI. To begin our frontend, we once again started with a flow chart, as the structure of our project was now going to change significantly. Our frontend GUI is handled solely by BlankClient, a transformation of our original class from terminal output to a Swing GUI that implements Runnable for concurrency. This class manages the control flow of our code, asking for different inputs from the user regarding what operations they would like to fulfill. Upon entering the system, users are welcomed and prompted for access. They can either log in with existing credentials or sign up for a new account, provided they enter a unique username and password. Users also specify if they are sellers or consumers during sign-up. For login, users input their username and password, which is then compared for equality against each User in the database. After successful login, users access an option menu tailored to their roles. All users can manage their ongoing conversations. Buyers can search for stores, block sellers, create messages, and import/export files. Sellers can search for and message buyers, import/export files, and block buyers. The system ensures a user-friendly experience, empowering both buyers and sellers in their online interactions. We implemented a latch to address challenges related to obtaining text input from our GUI. Initially, our code lacked a mechanism to delay until the user submitted an input, leading to the execution of subsequent code without the necessary input. To resolve this, we decided to initialize a latch with a value of 1. The main method waits for a response, and once the submit button is clicked, the latch is decremented to 0, allowing the execution of the next code block. Subsequently, the latch is reset to 1, ensuring the seamless functioning of the next input panel. While the latch serves as a temporary workaround, exploring solutions such as adopting an approach centered around monitoring button click events, may contribute to improved project structure. The BlankServer and BlankServerThread classes form the basis of our server side processing, creating individual threads for each connected user and managing client side requests. The BlankServer class initializes the connection and instantiates a BlankServerThread for each connection using a while loop that waits for a socket connection continuously. This approach enables the server to handle multiple clients concurrently in a separate and efficient manner, improving the responsiveness of our program significantly. One key component of the BlankServer class is its usage of the Database class. Here, a static instance of the class is declared, making an ArrayList of users on which operations can be performed. This class is crucial for centralizing our data in one place and ensuring persistence through sessions. Finally, we reused the implementation of our previous three classes â€“ User, Seller, and Consumer. Seller and Consumer are subclasses of User, which contains crucial methods used in the server for blocking, user identification, messaging, and file manipulation.
